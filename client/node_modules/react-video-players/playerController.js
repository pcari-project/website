'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lomit = require('lomit');

var _lomit2 = _interopRequireDefault(_lomit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var playerController = function playerController(PlayerComponent) {
  return function (_Component) {
    _inherits(_class, _Component);

    function _class(props) {
      _classCallCheck(this, _class);

      var _this = _possibleConstructorReturn(this, _Component.call(this, props));

      _this.onControlsPlay = _this.onControlsPlay.bind(_this);
      _this.onControlsPause = _this.onControlsPause.bind(_this);
      _this.onControlsSeek = _this.onControlsSeek.bind(_this);
      _this.onControlsVolumeChange = _this.onControlsVolumeChange.bind(_this);

      _this.onPlayerTimeUpdate = _this.onPlayerTimeUpdate.bind(_this);
      _this.onPlayerVolumeChange = _this.onPlayerVolumeChange.bind(_this);

      _this.state = {
        loop: props.loop,
        play: props.play,
        seekTo: props.time,
        time: props.time,
        volume: props.volume
      };
      return _this;
    }

    _class.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var loop = nextProps.loop,
          play = nextProps.play,
          time = nextProps.time,
          volume = nextProps.volume;


      this.setState({
        seekTo: time,
        loop: loop,
        play: play,
        volume: volume
      });
    };

    _class.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
      /**
       * @todo See if there could be any optimization introduced here. - Ryan
       */
      return true;
    };

    _class.prototype.onControlsPlay = function onControlsPlay() {
      this.setState({
        play: true
      });
    };

    _class.prototype.onControlsPause = function onControlsPause() {
      this.setState({
        play: false
      });
    };

    _class.prototype.onControlsSeek = function onControlsSeek(time) {
      this.setState({
        time: time
      });
    };

    _class.prototype.onControlsVolumeChange = function onControlsVolumeChange(volume) {
      this.setState({
        volume: volume
      });
    };

    _class.prototype.onPlayerTimeUpdate = function onPlayerTimeUpdate(time) {
      this.setState({
        time: time
      });

      if (this.props.onTimeUpdate) {
        this.props.onTimeUpdate(time);
      }
    };

    _class.prototype.onPlayerVolumeChange = function onPlayerVolumeChange(volume) {
      this.setState({
        volume: volume
      });

      if (this.props.onVolumeChange) {
        this.props.onVolumeChange(volume);
      }
    };

    _class.prototype.render = function render() {
      var _props = this.props,
          children = _props.children,
          controls = _props.controls;
      var _state = this.state,
          loop = _state.loop,
          play = _state.play,
          time = _state.time,
          seekTo = _state.seekTo,
          volume = _state.volume;


      var clonedControls = controls ? _react2.default.cloneElement(controls, {
        loop: loop,
        play: play,
        time: time,
        volume: volume,
        onPause: this.onControlsPause,
        onPlay: this.onControlsPlay,
        onSeek: this.onControlsSeek,
        onVolumeChange: this.onControlsVolumeChange
      }) : null;

      var cleanProps = (0, _lomit2.default)(this.props, ['controls', 'loop', 'play', 'time', 'volume', 'onTimeUpdate', 'onVolumeChange']);

      var cleanState = (0, _lomit2.default)(this.state, ['time']);

      return _react2.default.createElement(
        PlayerComponent,
        _extends({}, cleanProps, cleanState, {
          time: seekTo,
          onTimeUpdate: this.onPlayerTimeUpdate,
          onVolumeChange: this.onPlayerTimeUpdate
        }),
        clonedControls,
        children
      );
    };

    return _class;
  }(_react.Component);
};

exports.default = playerController;